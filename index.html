<!DOCTYPE html>
<html lang="en">
  <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
      <title>Technical Documentation Page</title>
      <link rel="stylesheet" href="styles.css">
  </head>
  <body>
      <nav id="navbar">
            <header>C++ Documentation</header>
            <ul>
            <li>
            <a class="nav-link" href="#Basic_Structure">Basic Structure</a>
            </li>
            <li>
            <a class="nav-link" href="#Interpreted_vs_Compiled_Languages">Interpreted vs Compiled Languages</a>
            </li>
            <li>
            <a class="nav-link" href="#C++_is_compiled_or_interpreted?">C++ is compiled or interpreted?</a>
            </li>
            <li>
            <a class="nav-link" href="#functions">Functions</a>
            </li>
            <li>
            <a class="nav-link" href="#Object-Oriented_Programming_(OOP)">Object-Oriented Programming (OOP)</a>
            </li>
            </ul>
      </nav>
      <main id="main-doc">
            <section class="main-section" id="Basic_Structure">
                <header><strong>Basic Structure</strong></header>
                <p>The basic structure of a C++ program typically consists of several elements, arranged in a specific order:</p>
                <ol>
                    <li><strong>Preprocessor Directives:</strong> These are lines in your code that begin with a hash (#) symbol. They are commands to the compiler to perform certain tasks before compilation. Common preprocessor directives include including header files (#include), defining constants (#define), and conditional compilation (#ifdef, #ifndef, #endif).</li>
                    <code>#include &lt;iostream&gt;
                    </code>
                    <li><strong>Namespace Declaration:</strong> Namespaces are used to organize code into logical groups and prevent naming conflicts. The standard namespace for C++ standard library functions is std.</li>
                    <code>using namespace std;
                    </code> 
                    <li><strong>Main Function:</strong> Every C++ program must have a main function. Execution of the program starts from the main function.</li>
                    <code>int main() {
                    &nbsp;&nbsp;&nbsp;// Your code here
                    &nbsp;&nbsp;&nbsp;return 0;
                    }
                    </code>  
                    <li><strong>Function Definitions:</strong> After the main function, you may define other functions that are called from within the main function or from other functions.</li>
                    <code>void myFunction() {
                    &nbsp;&nbsp;&nbsp;// Function code
                    </code>  
                    <li><strong>Variable Declarations:</strong> You can declare variables anywhere within the code. However, it's common to declare them at the beginning of functions or at the top of the file for global variables.</li>
                    <code>int myVariable = 10;
                    </code>
                    <li><strong>Statements and Expressions:</strong> These are the actual instructions that the program executes. Statements perform actions, and expressions produce values.</li>
                    <code>int sum = 5 + 7; // Expression
                    cout << "The sum is: " << sum << endl; // Statement
                    </code>
                    <li><strong>Comments:</strong> Comments are used to document your code for yourself and others. They are ignored by the compiler and serve as notes within the code.</li>
                    <code>// This is a single-line comment

                    /*
                    This is a
                    multi-line comment
                    */
                    </code>
                </ol>
            </section>
            <section class="main-section" id="Interpreted_vs_Compiled_Languages">
                <header><strong>Interpreted vs Compiled Languages</strong></header>
                  <p>Interpreted and compiled languages differ primarily in how they are executed:</p>
                  <ol>
                    <li><strong>Interpreted Languages:</strong></li>
                    <ul>
                      <li>Interpreted languages are executed line by line, directly by an interpreter program.</li>
                      <li>Code is translated into machine code at runtime.</li>
                      <li>Typically slower than compiled languages because of the overhead of interpretation during runtime.</li>
                      <li>Examples include Python, JavaScript, and Ruby.</li>
                    </ul>
                    <li><strong>Compiled Languages</strong></li>
                    <ul>
                      <li>Compiled languages are translated entirely into machine code before execution.</li>
                      <li>The translation process happens before runtime, typically by a compiler.</li>
                      <li>Typically slower than compiled languages because of the overhead of interpretation during runtime.</li>
                      <li>Results in faster execution because the code is already translated into machine code.</li>
                      <li>Compilation creates an executable file that can be run independently of the source code.</li>
                      <li>Examples include C++, Java (though it's both compiled and interpreted to bytecode), and Rust.</li>
                    </ul>
                  </ol>
              </section>
              <section class="main-section" id="C++_is_compiled_or_interpreted?">
                <header><strong>C++ is compiled or interpreted?</strong></header>
                <p>C++ is primarily a compiled language. When you write a C++ program, you typically use a compiler (such as GCC, Clang, or Microsoft Visual C++) to translate your human-readable code into machine code, which the computer can execute directly. This compilation process creates an executable file that can be run independently of the source code.</p>
              </section>
              <section class="main-section" id="functions">
                <header><strong>Functions</strong></header>
                <p>In C++, functions are blocks of code that perform a specific task. They are fundamental building blocks of C++ programs and help in organizing code, making it more modular, reusable, and easier to understand. Here's a basic overview of functions in C++:</p>
                <ol>
                  <li><strong>Syntax:</strong></li>
                  <ul>
                    <code>return_type function_name(parameters) {
                    &nbsp;&nbsp;&nbsp;// Function body
                    }
                    </code>
                    <li><strong>return_type:</strong> Specifies the data type of the value that the function returns. Use void if the function doesn't return any value.</li>
                    <li><strong>function_name:</strong> Name of the function, which should be unique within its scope and follow naming conventions.</li>
                    <li><strong>Parameters:</strong> Input values passed to the function. Parameters are optional, but if present, they should be declared within parentheses. Multiple parameters are separated by commas.</li>
                    <code>// Function declaration
                    int add(int a, int b) {
                    &nbsp;&nbsp;&nbsp;&nbsp;return a + b;
                    }
      
                    // Function call
                    int result = add(3, 5); // result will be 8
                    </code>
                  </ul>
                  <li><strong>Function Declaration vs. Definition:</strong></li>
                  <p><strong>Declaration:</strong> Tells the compiler about the existence of a function. It includes the function signature (name, return type, and parameters) and ends with a semicolon. Declarations are usually placed in header files or at the beginning of source files.</p>
                  <p><strong>Definition:</strong> Provides the implementation of the function. It includes the function body. Definitions are usually placed after the declaration.</p>
                  <li><strong>Function Prototypes:</strong></li>
                  <p>Function prototypes declare the function's signature before it's used in the program. This allows the compiler to recognize the function before its actual definition.</p>
                  <p>Prototypes are often placed in header files.</p>
                  <li><strong>Function Overloading:</strong></li>
                  <p>C++ allows defining multiple functions with the same name but different parameter lists. This is called function overloading.</p>
                  <p>Overloaded functions must have different parameter lists or different types of parameters.</p>
                </ol>
              </section>
              <section class="main-section" id="Object-Oriented_Programming_(OOP)">
                <header><strong>Object-Oriented Programming (OOP)</strong></header>
                <p>Object-Oriented Programming (OOP) in C++ provides a powerful way to organize and structure code, making it easier to manage and maintain. </p>
                  <ol>
                    <li><strong>Classes and Objects:</strong> Classes are user-defined data types that serve as blueprints for creating objects. Objects are instances of classes that encapsulate data (attributes) and behavior (methods).</li>
                    <code>#include &lt;iostream&gt;
      
                    // Class definition
                    class Rectangle {
                    public:
                    &nbsp;&nbsp;&nbsp;&nbsp;int length;
                    &nbsp;&nbsp;&nbsp;&nbsp;int width;
      
                    &nbsp;&nbsp;&nbsp;&nbsp;// Method to calculate area
                    &nbsp;&nbsp;&nbsp;&nbsp;int calculateArea() {
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return length * width;
                    &nbsp;&nbsp;&nbsp;}
                    };
      
                    int main() {
                    &nbsp;&nbsp;&nbsp;// Creating objects of the Rectangle class
                    &nbsp;&nbsp;&nbsp;Rectangle rect1;
                    &nbsp;&nbsp;&nbsp;rect1.length = 5;
                    &nbsp;&nbsp;&nbsp;rect1.width = 3;
      
                    &nbsp;&nbsp;&nbsp;// Accessing data members and methods using objects
                    &nbsp;&nbsp;&nbsp;std::cout << "Area of Rectangle: " << rect1.calculateArea() << std::endl;
      
                    &nbsp;&nbsp;&nbsp;return 0;
                    }
                    </code>
                    <li><strong>Encapsulation:</strong> Refers to bundling data (attributes) and methods (functions) that operate on the data into a single unit (class). It hides the internal implementation details of an object and provides controlled access to its members.</li>
                    <code>#include &lt;iostream&gt;
                    #include &lt;string&gt;
      
                    class Employee {
                    private:
                    &nbsp;&nbsp;&nbsp;std::string name;
                    &nbsp;&nbsp;&nbsp;int age;
      
                    public:
                    &nbsp;&nbsp;&nbsp;// Setter methods for name and age
                    &nbsp;&nbsp;&nbsp;void setName(std::string newName) {
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name = newName;
                    &nbsp;&nbsp;&nbsp;}
      
                    &nbsp;&nbsp;&nbsp;void setAge(int newAge) {
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;age = newAge;
                    &nbsp;&nbsp;&nbsp;}
      
                    &nbsp;&nbsp;&nbsp;// Getter methods for name and age
                    &nbsp;&nbsp;&nbsp;std::string getName() {
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return name;
                    &nbsp;&nbsp;&nbsp;}
      
                    &nbsp;&nbsp;&nbsp;int getAge() {
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return age;
                    &nbsp;&nbsp;&nbsp;}
                    };
      
                    int main() {
                    &nbsp;&nbsp;&nbsp;// Creating an object of the Employee class
                    &nbsp;&nbsp;&nbsp;Employee emp1;
      
                    &nbsp;&nbsp;&nbsp;// Setting and accessing private members using public methods
                    &nbsp;&nbsp;&nbsp;emp1.setName("John");
                    &nbsp;&nbsp;&nbsp;emp1.setAge(30);
      
                    &nbsp;&nbsp;&nbsp;std::cout << "Employee Name: " << emp1.getName() << std::endl;
                    &nbsp;&nbsp;&nbsp;std::cout << "Employee Age: " << emp1.getAge() << std::endl;
      
                    return 0;
                    }
                    </code>
                    <li><strong>Inheritance:</strong> Allows a class (derived or child class) to inherit properties and behaviors from another class (base or parent class). It promotes code reuse and facilitates the creation of a hierarchy of classes.</li>
                    <code>#include &lt;iostream&gt;
      
                    // Base class
                    class Shape {
                    public:
                    &nbsp;&nbsp;&nbsp;void draw() {
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout << "Drawing a shape." << std::endl;
                    &nbsp;&nbsp;&nbsp;}
                    };
      
                    // Derived class
                    class Circle : public Shape {
                    public:
                    &nbsp;&nbsp;&nbsp;void draw() {
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout << "Drawing a circle." << std::endl;
                    &nbsp;&nbsp;&nbsp;}
                    };
      
                    int main() {
                    &nbsp;&nbsp;&nbsp;// Creating an object of the Circle class
                    &nbsp;&nbsp;&nbsp;Circle circle;
      
                    &nbsp;&nbsp;&nbsp;// Accessing methods from the base and derived classes
                    &nbsp;&nbsp;&nbsp;circle.draw(); // Output: "Drawing a circle."
      
                    &nbsp;&nbsp;&nbsp;return 0;
                    }
                    </code>
                    <li><strong>Polymorphism:</strong> Allows objects of different classes to be treated as objects of a common superclass. It enables methods to be invoked based on the actual object type at runtime, promoting flexibility and extensibility.</li>
                    <code>#include &lt;iostream&gt;
      
                    // Base class
                    class Animal {
                    public:
                    &nbsp;&nbsp;&nbsp;// Virtual method
                    &nbsp;&nbsp;&nbsp;virtual void makeSound() {
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout << "Animal makes a sound." << std::endl;
                    &nbsp;&nbsp;&nbsp;}
                    };
      
                    // Derived class
                    class Dog : public Animal {
                    public:
                    &nbsp;&nbsp;&nbsp;// Override method
                    &nbsp;&nbsp;&nbsp;void makeSound() override {
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout << "Dog barks." << std::endl;
                    &nbsp;&nbsp;&nbsp;}
                    };
      
                    int main() {
                    &nbsp;&nbsp;&nbsp;// Creating a pointer to the base class
                    &nbsp;&nbsp;&nbsp;Animal* animal = new Dog();
      
                    &nbsp;&nbsp;&nbsp;// Accessing overridden method using base class pointer
                    &nbsp;&nbsp;&nbsp;animal->makeSound(); // Output: "Dog barks."
      
                    &nbsp;&nbsp;&nbsp;delete animal; // Freeing allocated memory
      
                    &nbsp;&nbsp;&nbsp;return 0;
                    }
                    </code>
                    <li><strong>Abstraction:</strong> Involves hiding the complex implementation details of objects and exposing only the essential features. It allows programmers to focus on what an object does rather than how it does it.</li>
                    <p>Sample: Abstraction is a design concept and doesn't have a direct code representation. However, classes and interfaces in C++ can be used to achieve abstraction by providing a clear separation between interface and implementation details.</p>
                  </ol>
              </section>
        </main>
  </body>
</html>